---SECURE BUFFER PROPERTIES---
prevents swapping to disk             mlock() or sodium_mlock() after malloc() / sodium_malloc()
avoids accidental copies              never return the pointer; pass references only
clears remnants before free           sodium_memzero() or a volatile loop
ensures OS can reuse page safely      sodium_free() or munlock()+free()

---INPUT DIRECT IN SECURE BUFFER---
System call to read?
Read from the terminal (or a dedicated fd) with echo disabled using termios:
struct termios old, noecho;
tcgetattr(STDIN_FILENO, &old);
noecho = old;
noecho.c_lflag &= ~(ECHO);
tcsetattr(STDIN_FILENO, TCSAFLUSH, &noecho);
read(STDIN_FILENO, buf, len);
tcsetattr(STDIN_FILENO, TCSAFLUSH, &old);

!This avoids an intermediate string in libc.
!Don’t use scanf/getline/fgets — they allocate temporary buffers.

---ENV & OS HARDENING---
prevents secrets in crash dumps     Disable core dumps (setrlimit(RLIMIT_CORE, 0) or prctl(PR_SET_DUMPABLE, 0))
Clear environment variables and argv after parsing
Run with minimal privileges
Wipe stack frames if sensitive data was placed on the stack (volatile zero loop)

---COMPILER OPTIMIZATION---
Libraries should already handle this on their own
Mark the zeroing function volatile or use sodium_memzero() so the compiler cannot optimize it away.
Compile with stack-protector options (-fstack-protector-strong) and position-independent code to avoid ROP issues.

---ENCRYPTION DECRYPTION---
AES instruction set

If you want AES-NI guarantees you can call OpenSSL EVP from C; libsodium chooses safe primitives (ChaCha20/Poly1305) that are also side-channel resistant and fast.

---ADDITIONAL STUFF---
❗ Additional important items / gotchas (don’t miss these)

Security, lifecycle, and system interactions you must handle in the C layer:

Init libsodium

Call sodium_init() early in the C module.

Disable core dumps (process-wide)

setrlimit(RLIMIT_CORE, 0) or prctl(PR_SET_DUMPABLE, 0) to avoid crashes dumping secrets.

Terminal handling & secure input

Use tcgetattr/tcsetattr to disable echo and canonical mode, read directly with read(2) into the mlocked buffer, and restore tty state even on signals.

Signal safety

Install handlers for SIGINT, SIGTERM, SIGHUP that restore terminal state and zero buffers before exit. Use async-safe code in signal handler (set flag, handle in main loop), or use sigaction with care.

No Ruby-side pointers

Return opaque integer handles or status codes to Ruby, never raw pointer addresses (to avoid accidental access or copying).

Avoid accidental forks

fork() duplicates memory; child process will have copies of secret. If you must fork, zero buffers in child immediately or avoid forking while secrets live. Consider running C worker that exits after use.

Threading

Protect buffer access with locks in C if multiple threads can call the native API.

Timing/side-channels in your code

Use library functions that are constant-time. Don’t write secret-dependent branching in C.

AES-NI / hardware detection

If you require AES and AES-NI specifically, use OpenSSL EVP in C (it uses AES-NI when present). Libsodium uses safe primitives; you don’t need to reinvent AES usage.

Zeroing & free guarantees

Always use sodium_memzero (or OPENSSL_cleanse) and sodium_free. Don’t rely on free + memset.

Environment & argv

Erase or avoid storing secrets in environment variables or argv.

Permissions & least privilege

Run with minimal privileges; consider dropping caps after startup.

Auditing & tests

Test for accidental copies: run memory-dump tests, core-dump off, check /proc/<pid>/maps and use tools to ensure no visible secret outside buffer.
